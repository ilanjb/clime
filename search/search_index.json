{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Auto-generated, Argparse based, CLIs from attrs classes. Full docs here: https://ilanjb.github.io/clime/","title":"CliMe"},{"location":"tutorials/about/features/","text":"Features \u00b6 Say you wrote an amazing class like this: from enum import Enum from typing import Optional import attr class Colors ( Enum ): red = \"red\" # or 1 or auto()... blue = \"blue\" @attr . s ( auto_attribs = True ) class Dude : \"\"\" Everything about the Dude! \"\"\" name : str favorite_color : Colors age_in_years : Optional [ int ] = None def state_name ( self ): print ( f \"hi! my name is { self . name } \" ) def profess_favorite_color ( self ): print ( f \"my favorite color is { self . favorite_color . name } \" ) # we're dealing with Enums here! def volunteer_age ( self ): if self . age_in_years is not None : # 0 counts! print ( f \"I am { self . age_in_years } years old.\" ) else : print ( \"A script never reveals its age\" ) def introduce ( self ): self . state_name () self . profess_favorite_color () self . volunteer_age () Now you want to show it off to your friends. Which means you are probably going to have make a CLI... Auto-generated, Argparse based, CLIs from attrs classes in one function.. \u00b6 With CliMe, all you have to do is this: from clime import clime from docs_src.sample_usage.tutorial_001 import Dude def main (): \"\"\" CliMe it! :return: \"\"\" dude : Dude = clime ( Dude ) dude . introduce () if __name__ == \"__main__\" : main () Check it: $ python \\d ocs_src \\s ample_usage \\t utorial_002.py --help usage: Everything about the Dude! positional arguments: name type: <str> {Colors.red,Colors.blue} type: <Colors> optional arguments: -h, --help show this help message and exit --age-in-years AGE_IN_YEARS type: <int> (default: None) did you see that? Argument names are taken from that attributes Argument types are taken from that type annotations, and converted for you! Help is taken from the docstrings. All you did was CliMe it! No Duplicate code! \u00b6 Making a custom ArgumentParser for Dude would look like this from argparse import ArgumentParser from docs_src.sample_usage.tutorial_001 import Dude , Colors def main (): \"\"\" make a parser. parser the args. convert the args pass to Dude. :return: \"\"\" # make the parser parser = ArgumentParser () # add the arguments. These must match the arguments from the class # If Dude's signature changes, dont forget to update here!!! parser . add_argument ( \"name\" ) parser . add_argument ( \"favorite_color\" , choices = Colors . __members__ ) parser . add_argument ( \"--age-in-years\" , type = int ) # parse args = parser . parse_args () # convert args not handled by ArgumentParser favorite_color = Colors [ args . favorite_color ] # I hope I spelled that right! # instantiate and go dude : Dude = Dude ( args . name , favorite_color , age_in_years = args . age_in_years ) dude . introduce () if __name__ == \"__main__\" : main () Note how much duplicate code CliMe saves you. With CliMe, any changes to Dude's signature are automatically updated in the CLI! Code Completion! \u00b6 Since CliMe returns an instance of your class, you IDE will be eager to help Compare that to the Namespace returned by ArgumentParser.parser_args():","title":"Features"},{"location":"tutorials/about/features/#features","text":"Say you wrote an amazing class like this: from enum import Enum from typing import Optional import attr class Colors ( Enum ): red = \"red\" # or 1 or auto()... blue = \"blue\" @attr . s ( auto_attribs = True ) class Dude : \"\"\" Everything about the Dude! \"\"\" name : str favorite_color : Colors age_in_years : Optional [ int ] = None def state_name ( self ): print ( f \"hi! my name is { self . name } \" ) def profess_favorite_color ( self ): print ( f \"my favorite color is { self . favorite_color . name } \" ) # we're dealing with Enums here! def volunteer_age ( self ): if self . age_in_years is not None : # 0 counts! print ( f \"I am { self . age_in_years } years old.\" ) else : print ( \"A script never reveals its age\" ) def introduce ( self ): self . state_name () self . profess_favorite_color () self . volunteer_age () Now you want to show it off to your friends. Which means you are probably going to have make a CLI...","title":"Features"},{"location":"tutorials/about/features/#auto-generated-argparse-based-clis-from-attrs-classes-in-one-function","text":"With CliMe, all you have to do is this: from clime import clime from docs_src.sample_usage.tutorial_001 import Dude def main (): \"\"\" CliMe it! :return: \"\"\" dude : Dude = clime ( Dude ) dude . introduce () if __name__ == \"__main__\" : main () Check it: $ python \\d ocs_src \\s ample_usage \\t utorial_002.py --help usage: Everything about the Dude! positional arguments: name type: <str> {Colors.red,Colors.blue} type: <Colors> optional arguments: -h, --help show this help message and exit --age-in-years AGE_IN_YEARS type: <int> (default: None) did you see that? Argument names are taken from that attributes Argument types are taken from that type annotations, and converted for you! Help is taken from the docstrings. All you did was CliMe it!","title":"Auto-generated, Argparse based, CLIs from attrs classes in one function.."},{"location":"tutorials/about/features/#no-duplicate-code","text":"Making a custom ArgumentParser for Dude would look like this from argparse import ArgumentParser from docs_src.sample_usage.tutorial_001 import Dude , Colors def main (): \"\"\" make a parser. parser the args. convert the args pass to Dude. :return: \"\"\" # make the parser parser = ArgumentParser () # add the arguments. These must match the arguments from the class # If Dude's signature changes, dont forget to update here!!! parser . add_argument ( \"name\" ) parser . add_argument ( \"favorite_color\" , choices = Colors . __members__ ) parser . add_argument ( \"--age-in-years\" , type = int ) # parse args = parser . parse_args () # convert args not handled by ArgumentParser favorite_color = Colors [ args . favorite_color ] # I hope I spelled that right! # instantiate and go dude : Dude = Dude ( args . name , favorite_color , age_in_years = args . age_in_years ) dude . introduce () if __name__ == \"__main__\" : main () Note how much duplicate code CliMe saves you. With CliMe, any changes to Dude's signature are automatically updated in the CLI!","title":"No Duplicate code!"},{"location":"tutorials/about/features/#code-completion","text":"Since CliMe returns an instance of your class, you IDE will be eager to help Compare that to the Namespace returned by ArgumentParser.parser_args():","title":"Code Completion!"},{"location":"tutorials/booleans/","text":"CliMe uses argparse's \"store_true\" and \"store_false\" to convert attrs boolean attributes to CLI. For this to work smoothly: boolean arguments must be given a default value boolean arguments cannot be optional","title":"Intro"},{"location":"tutorials/booleans/default_false/","text":"Boolean attributes must be given a default value. When set defaulted to False , CliMe will use ArguementParsers's action=\"store_false\" . Using the flag will set it to True import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : likes_ice_cream : bool = False def declare_ice_cream_status ( self ): negate = \" do not\" if not self . likes_ice_cream else \"\" print ( f \"hi! i { negate } like ice cream\" ) def main (): clime ( Dude ) . declare_ice_cream_status () if __name__ == \"__main__\" : main () Check it: $ python tutorial_001.py --help usage: tutorial_001.py [-h] [--likes-ice-cream] optional arguments: -h, --help show this help message and exit --likes-ice-cream (default: False) Super! note: CliMe converts underscores from variable names to dashes in the CLI In the this case 'likes_ice_cream' became 'likes-ice-cream' Running without arguments will keep that attribute False . Try it! $ python tutorial_001.py hi! i do not like ice cream Running with the --likes-ice-cream flag will set the attribute True . $ python tutorial_001.py --likes-ice-cream hi! i like ice cream It works with flags! That's it. For boolean arguments just set a default value!","title":"Default False"},{"location":"tutorials/enums/","text":"ArgumentParser natively supports 'choices'. Choices cannot be type hinted by attrs attributes. You know what can? Enum If your interested in how to joyfully use Enums in python, check out Making Enums (as always, arguably) more Pythonic","title":"Intro"},{"location":"tutorials/enums/enums/","text":"Any custom Enum class can be used to annotate an attribute and converted into an argument. from enum import Enum import attr from clime import clime class Colors ( Enum ): red = \"red\" # or 1 or auto()... blue = \"blue\" @attr . s ( auto_attribs = True ) class Dude : favorite_color : Colors def profess_favorite_color ( self ): print ( f \"my favorite color is { self . favorite_color . name } \" ) # we're dealing with Enums here! def main (): clime ( Dude ) . profess_favorite_color () if __name__ == \"__main__\" : main () Check it: $ python tutorial_001.py --help usage: tutorial_001.py [-h] {Colors.red,Colors.blue} positional arguments: {Colors.red,Colors.blue} type: <Colors> optional arguments: -h, --help show this help message and exit Note that the choices given are a bit misleading Colors.red should be entered as red. If you have a better solution than one of Raymond Hettinger suggestions please let me know. Super! Try it: $ python tutorial_001.py blue my favorite color is blue Nice! If you give it a bad option, ArgumentParser will give you a nice message: $ python tutorial_001.py chocolate usage: tutorial_001.py [-h] {Colors.red,Colors.blue} tutorial_001.py: error: argument favorite_color: invalid Colors value: 'chocolate' That's it. To use choices, just annotate with an Enum class.","title":"Enums"},{"location":"tutorials/help/","text":"Everyone wants a good --help. CliMe tries to help.","title":"Intro"},{"location":"tutorials/help/help/","text":"Help can be added per attribute via the metadata kwarg of attrs.ib import attr from clime import clime @attr . s # dont need auto_attribs, but it wouldn't hurt... class Dude : name : str = attr . ib ( metadata = { \"help\" : \"Your first name\" } ) # help per attibute is taken from the metadata kwarg in attr.ib def introduce ( self ): print ( f \"hi! my name is { self . name } \" ) def main (): clime ( Dude ) . introduce () if __name__ == \"__main__\" : main () Check it: python tutorial_001.py --help usage: tutorial_001.py [-h] name positional arguments: name Your first name optional arguments: -h, --help show this help message and exit Cool! Actually, of all of the features of CliMe, this one seems the most clunky. Better ideas?","title":"Help"},{"location":"tutorials/help/usage/","text":"The docstrings of the class are passed to ArgumentParser for the usage kwarg. import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : # docstrings will be taken for the ArgumentParser \"usage\" \"\"\" Amaze your friends by printing you name to the console \"\"\" name : str def introduce ( self ): print ( f \"hi! my name is { self . name } \" ) def main (): clime ( Dude ) . introduce () if __name__ == \"__main__\" : main () Check it: python tutorial_001.py --help usage: Amaze your friends by printing you name to the console positional arguments: name type: <str> optional arguments: -h, --help show this help message and exit Cool! That's it... To add a usage message just add docstrings to your class","title":"Usage"},{"location":"tutorials/integers_floats_and_other_simple_classes/","text":"CliMe will convert any annotation into a type arguments for ArgumentParser. This will work well for any class that can be instantiated with a string. The following classes are converted automatically: int float ord str Path Other classes (including you own custom classes) will be converted after checking that they can be instantiated with a string. Thee following demo works with int as an example.","title":"Intro"},{"location":"tutorials/integers_floats_and_other_simple_classes/integers/","text":"Attributes annotated with int are converted to type=int in ArgumentParser import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : age_in_years : int def confess_age ( self ): print ( f \"I am { self . age_in_years } years old.\" ) def main (): clime ( Dude ) . confess_age () if __name__ == \"__main__\" : main () Check it: $ python docs_src/integers_floats_and_other_simple_classes/tutorial_001.py usage: tutorial_001.py [-h] age_in_years positional arguments: age_in_years type: <int> optional arguments: -h, --help show this help message and exit Cool! age_in_years is annotated with int CliMe takes converts it into an integer Try it! $ python docs_src/integers_floats_and_other_simple_classes/tutorial_001.py 12 I am 12 years old. Non-integers will be caught by ArgumentParser $ python docs_src/integers_floats_and_other_simple_classes/tutorial_001.py hi usage: tutorial_001.py [-h] age_in_years tutorial_001.py: error: argument age_in_years: invalid int value: 'hi' $ python docs_src/integers_floats_and_other_simple_classes/tutorial_001.py 12 .1 usage: tutorial_001.py [-h] age_in_years tutorial_001.py: error: argument age_in_years: invalid int value: '12.1' That's it.","title":"Integers"},{"location":"tutorials/integers_floats_and_other_simple_classes/optional_integers/","text":"Type conversion works with Optional annotations, too from typing import Optional import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : age_in_years : Optional [ int ] = None def volunteer_age ( self ): if self . age_in_years is not None : # 0 counts! print ( f \"I am { self . age_in_years } years old.\" ) else : print ( \"A script never reveals its age\" ) def main (): clime ( Dude ) . volunteer_age () if __name__ == \"__main__\" : main () Check it: $ python docs_src/integers_floats_and_other_simple_classes/tutorial_002.py usage: tutorial_002.py [-h] [--age-in-years AGE_IN_YEARS] optional arguments: -h, --help show this help message and exit --age-in-years AGE_IN_YEARS type: <int> (default: None) optional arguments: -h, --help show this help message and exit Cool! age_in_years is annotated with Optional[int] CliMe takes converts it an optional argument Try it! No arguments: $ python docs_src/integers_floats_and_other_simple_classes/tutorial_002.py --age-in-years 12 I am 12 years old. With arguments: $ python docs_src/integers_floats_and_other_simple_classes/tutorial_002.py A script never reveals its age That's it.","title":"Optional Integers"},{"location":"tutorials/strings/","text":"Strings are easy since the default type of argumets in ArgumentParser are strings.","title":"Intro"},{"location":"tutorials/strings/defaults/","text":"To use default values, just add a default value to the attribute import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : name : str = \"joe\" # attributes with default values in the class will be set as optional arguments in the cli def state_name ( self ): print ( f \"hi! my name is { self . name } \" ) def main (): clime ( Dude ) . state_name () if __name__ == \"__main__\" : main () Check it: $ python tutorial_002.py --help usage: tutorial_002.py [-h] [--name NAME] optional arguments: -h, --help show this help message and exit --name NAME (default: joe) Super! Name is now a positional argument with a defaul value. The default value is added to the --help. Try it! $ python tutorial_002.py hi! my name is joe It works with defaults! $ python tutorial_002.py --name mike hi! my name is mike It works with optional arguments! Want to know what will not work? Positional arguments: $ python tutorial_002.py mike usage: tutorial_002.py [-h] [--name NAME] tutorial_002.py: error: unrecognized arguments: mike Note that this is an unfortunate difference between argument parser and the underlying class init. The class can attributes with default argument as positional. Argument parser cannot. Anyways... that's it. All you need to take use default values is give the attribute a default value!","title":"Default Values"},{"location":"tutorials/strings/optional_defaults/","text":"Defaults can be set to None, too. from typing import Optional import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : name : Optional [ str ] = None # defaults can be set to None. Make sure to annotate as Optional def state_name ( self ): if self . name : print ( f \"hi! my name is { self . name } \" ) else : print ( f \"hi! my name is a secret\" ) def main (): clime ( Dude ) . state_name () if __name__ == \"__main__\" : main () Check it: $ python tutorial_003.py --help usage: tutorial_003.py [-h] [--name NAME] optional arguments: -h, --help show this help message and exit --name NAME (default: None) Super! Name is now a positional argument with a defaul value. The default value is added to the --help. Try it! $ python tutorial_003.py hi! my name is a secret It works with defaults! $ python tutorial_003.py --name mike hi! my name is mike It works with optional arguments! That's it. Go ahead. Default to None !","title":"Optional Default Values"},{"location":"tutorials/strings/positional/","text":"Getting stated with strings is a simple as calling clime() on an attrs class: import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : name : str # attributes without default values in the class will be set as positional arguments in the cli def state_name ( self ): print ( f \"hi! my name is { self . name } \" ) def main (): clime ( Dude ) . state_name () if __name__ == \"__main__\" : main () Check it: $ python main.py usage: tutorial_001.py [-h] name positional arguments: name optional arguments: -h, --help show this help message and exit Cool! Dude is a normal attrs decorated class. Name is a an argument type annotated with str . CliMe takes the class and turns it into a CLI with the builtin ArgumentParser. Try it! $ python main.py joe hi! my name is joe It works! Want to know what will not work? No arguments: $ python main.py usage: tutorial_001.py [-h] name tutorial_001.py: error: the following arguments are required: name Or using --name as on optional argument.. $ python main.py usage: tutorial_001.py [-h] name tutorial_001.py: error: unrecognized arguments: --name Note that this is an unfortunate difference between argument parser and the underlying class init. The class can take kwargs as positional. Argument parser cannot. Anyways... that's it. All you need to take positional strings is an attrs decorated class with a str annotated class variable.","title":"Positional"},{"location":"tutorials/superchargewithattrib/","text":"Use the power of attr.ib to supercharge your CliMe. It's way more fun than ArgumentParser.","title":"Intro"},{"location":"tutorials/superchargewithattrib/converters/","text":"Lets say you want all names to be capitalized, but you're happy to be flexible on input. Ie Joe, joe, JOE and even jOe should all be understood as Joe Just use attrs converters ... import attr from clime import clime @attr . s ( auto_attribs = True ) class Dude : name : str = attr . ib ( converter = str . capitalize ) def introduce ( self ): print ( f \"hi! my name is { self . name } \" ) def main (): clime ( Dude ) . introduce () if __name__ == \"__main__\" : main () Try it! $ python main.py joe hi! my name is Joe It works! When using an explicit converter, Clime will not try to convert the input into the annotated type. That means you can do whatever you want with as long as it starts with a string. Here, we input a date: import attr from clime import clime import datetime def year_month_day_to_date ( year_month_day ) -> datetime . date : \"\"\" '2000-11-22' -> :param year_month_day: :return: \"\"\" return datetime . datetime . strptime ( year_month_day , \"%Y-%m- %d \" ) . date () @attr . s class Dude : birthday : datetime . date = attr . ib ( converter = year_month_day_to_date ) # attributes with explicity converters will be taken with argument parser as strings # you can do whatver you want with them! def print_my_birthday ( self ): print ( f \"My birthday is { self . birthday } \" ) def main (): clime ( Dude ) . print_my_birthday () if __name__ == \"__main__\" : main () Try it! $ python \\d ocs_src \\s upercharge_with_attrib \\t utorial_003.py 2000 -11-22 My birthday is 2000-11-22 It works! But what if the date is invalid? Lets check... $ python \\d ocs_src \\s upercharge_with_attrib \\t utorial_003.py 2000 -13-22 Traceback (most recent call last): File \"\\docs_src\\supercharge_with_attrib\\tutorial_003.py\", line 29, in <module> main() File \"\\docs_src\\supercharge_with_attrib\\tutorial_003.py\", line 25, in main clime(Dude).print_my_birthday() File \"\\clime\\clime.py\", line 100, in clime return attrs_decorated_class(**args.__dict__) File \"<attrs generated init __main__.Dude>\", line 2, in __init__ File \"\\docs_src\\supercharge_with_attrib\\tutorial_003.py\", line 14, in year_month_day_to_date return datetime.datetime.strptime(year_month_day, '%Y-%m-%d').date() File \"C:\\Program Files\\Python38\\lib\\_strptime.py\", line 568, in _strptime_datetime tt, fraction, gmtoff_fraction = _strptime(data_string, format) File \"C:\\Program Files\\Python38\\lib\\_strptime.py\", line 349, in _strptime raise ValueError(\"time data %r does not match format %r\" % ValueError: time data '2000-13-22' does not match format '%Y-%m-%d' 2000-13-22 is not a valid date so the conversion fails. In other words, the conversion acts as an implicit validator . Amazing!","title":"Converters"},{"location":"tutorials/superchargewithattrib/validators/","text":"Lets say you want all want to validate your input. Just use attrs validators ... import attr from clime import clime def x_smaller_than_100 ( instance , attribute , value ): if not value < 100 : raise ValueError ( f \" { attribute . name } has to be smaller than 100!\" ) @attr . s class Dude : favorite_number_less_than_100 : int = attr . ib ( validator = [ attr . validators . instance_of ( int ), x_smaller_than_100 ] ) def print_favorite_number_less_than_100 ( self ): print ( f \"My favorite number less than 100 is { self . favorite_number_less_than_100 } \" ) def main (): clime ( Dude ) . print_favorite_number_less_than_100 () if __name__ == \"__main__\" : main () Try it! $ python docs_src \\s upercharge_with_attrib \\t utorial_002.py 10 My favorite number less than 100 is 10 What if you enter and invalid input? $ python docs_src \\s upercharge_with_attrib \\t utorial_002.py 101 Traceback (most recent call last): File \"C:\\Users\\ilanb\\PycharmProjects\\attrsargparser\\docs_src\\supercharge_with_attrib\\tutorial_002.py\", line 24, in <module> main() File \"C:\\Users\\ilanb\\PycharmProjects\\attrsargparser\\docs_src\\supercharge_with_attrib\\tutorial_002.py\", line 20, in main clime(Dude).print_favorite_number_less_than_100() File \"C:\\Users\\ilanb\\PycharmProjects\\attrsargparser\\clime\\clime.py\", line 100, in clime return attrs_decorated_class(**args.__dict__) File \"<attrs generated init __main__.Dude>\", line 4, in __init__ File \"C:\\Users\\ilanb\\PycharmProjects\\attrsargparser\\venv\\lib\\site-packages\\attr\\_make.py\", line 2975, in __call__ v(inst, attr, value) File \"C:\\Users\\ilanb\\PycharmProjects\\attrsargparser\\docs_src\\supercharge_with_attrib\\tutorial_002.py\", line 9, in x_smaller_than_100 raise ValueError(f\"{attribute.name} has to be smaller than 100!\") ValueError: favorite_number_less_than_100 has to be smaller than 100! You won't do that again!","title":"Validators"}]}